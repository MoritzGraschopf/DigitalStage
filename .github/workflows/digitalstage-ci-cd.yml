name: DigitalStage CI/CD

on:
  push:
    branches: [ "main" ]

env:
  REGISTRY: digitalstage.liveroom.at
  APP_IMAGE: digitalstage.liveroom.at/digitalstage-app
  WS_IMAGE: digitalstage.liveroom.at/digitalstage-websocket

jobs:
  build-and-push:
    name: Build & Push Images to Private Registry
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Login to registry
        run: |
          echo "${{ secrets.REGISTRY_PASSWORD }}" | docker login ${{ env.REGISTRY }} \
            -u "${{ secrets.REGISTRY_USER }}" --password-stdin

      - name: Build app image
        run: |
          docker build \
            -f docker/Dockerfile \
            -t $APP_IMAGE:latest \
            -t $APP_IMAGE:${{ github.sha }} \
            .

      - name: Build websocket image
        run: |
          docker build \
            -f docker/Dockerfile.ws \
            -t $WS_IMAGE:latest \
            -t $WS_IMAGE:${{ github.sha }} \
            apps/websocket

      - name: Push images
        run: |
          docker push $APP_IMAGE:latest
          docker push $APP_IMAGE:${{ github.sha }}
          docker push $WS_IMAGE:latest
          docker push $WS_IMAGE:${{ github.sha }}

  deploy:
    name: Deploy to Debian Server
    needs: build-and-push
    runs-on: ubuntu-latest

    steps:
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SERVER_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          printf "Host server\n  HostName %s\n  User %s\n  IdentityFile ~/.ssh/id_ed25519\n  StrictHostKeyChecking no\n" \
            "${{ secrets.SERVER_HOST }}" "${{ secrets.SERVER_USER }}" >> ~/.ssh/config

      - name: Deploy via SSH (force git + docker compose + registry cleanup)
        run: |
          ssh server << 'EOF'
          set -euo pipefail

          cd /opt/digitalstage

          echo ">>> Resetting repo to remote state..."
          git fetch origin
          git reset --hard origin/main

          echo ">>> Rewriting .env from GitHub Secrets..."
          cat > .env << 'ENVEOF'
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          JWT_SECRET=${{ secrets.JWT_SECRET }}
          NEXT_PUBLIC_WS_URL=${{ secrets.NEXT_PUBLIC_WS_URL }}
          NEXT_PUBLIC_STUN_URL=${{ secrets.NEXT_PUBLIC_STUN_URL }}
          ANNOUNCED_IP=${{ secrets.ANNOUNCED_IP }}
          MEDIASOUP_MIN_PORT=${{ secrets.MEDIASOUP_MIN_PORT }}
          MEDIASOUP_MAX_PORT=${{ secrets.MEDIASOUP_MAX_PORT }}
          MEDIASOUP_LISTEN_IP=${{ secrets.MEDIASOUP_LISTEN_IP }}
          NODE_ENV=${{ secrets.NODE_ENV }}
          ENVEOF
          chmod 600 .env

          echo ">>> Pulling latest images..."
          docker compose -f docker-compose.yaml pull

          echo ">>> Starting containers..."
          docker compose -f docker-compose.yaml up -d

          echo ">>> Cleaning old Docker resources on server..."
          docker container prune -f
          docker image prune -a -f --filter "until=168h"
          docker image prune -f
          docker builder prune -a -f

          echo ">>> Cleaning old versions in PRIVATE REGISTRY (older than 24h)..."
          REGISTRY_HOST="${{ env.REGISTRY }}"
          REGISTRY_USER="${{ secrets.REGISTRY_USER }}"
          REGISTRY_PASS="${{ secrets.REGISTRY_PASSWORD }}"
          KEEP_SHA="${{ github.sha }}"
          CUTOFF_SECONDS=86400

          python3 - << 'PY'
          import json, os, subprocess, sys, time
          from datetime import datetime, timezone

          host = os.environ["REGISTRY_HOST"]
          user = os.environ["REGISTRY_USER"]
          pw   = os.environ["REGISTRY_PASS"]
          keep_sha = os.environ["KEEP_SHA"]
          cutoff = int(os.environ.get("CUTOFF_SECONDS","86400"))
          now = int(time.time())

          def curl(url, method="GET", headers=None, want_headers=False):
            cmd = ["curl", "-sS", "-u", f"{user}:{pw}"]
            if want_headers:
              cmd += ["-D", "-"]   # dump headers to stdout
              cmd += ["-o", "/dev/null"]
            if method != "GET":
              cmd += ["-X", method]
            if headers:
              for k,v in headers.items():
                cmd += ["-H", f"{k}: {v}"]
            cmd.append(url)
            p = subprocess.run(cmd, capture_output=True, text=True)
            if p.returncode != 0:
              raise RuntimeError(p.stderr.strip() or p.stdout.strip())
            return p.stdout

          def curl_json(url, headers=None):
            cmd = ["curl", "-sS", "-u", f"{user}:{pw}"]
            if headers:
              for k,v in headers.items():
                cmd += ["-H", f"{k}: {v}"]
            cmd.append(url)
            p = subprocess.run(cmd, capture_output=True, text=True)
            if p.returncode != 0:
              raise RuntimeError(p.stderr.strip() or p.stdout.strip())
            if not p.stdout.strip():
              return None
            return json.loads(p.stdout)

          base = f"https://{host}"

          # list repositories
          catalog = curl_json(f"{base}/v2/_catalog") or {}
          repos = catalog.get("repositories", []) or []

          deleted = 0
          for repo in repos:
            tags_doc = curl_json(f"{base}/v2/{repo}/tags/list") or {}
            tags = tags_doc.get("tags") or []
            for tag in tags:
              # keep latest and current sha tag
              if tag == "latest" or tag == keep_sha:
                continue

              # get manifest (headers -> Docker-Content-Digest)
              hdrs = curl(
                f"{base}/v2/{repo}/manifests/{tag}",
                headers={"Accept":"application/vnd.docker.distribution.manifest.v2+json"},
                want_headers=True
              )
              digest = None
              for line in hdrs.splitlines():
                if line.lower().startswith("docker-content-digest:"):
                  digest = line.split(":",1)[1].strip()
                  break
              if not digest:
                continue

              # get manifest json to find config digest
              manifest = curl_json(
                f"{base}/v2/{repo}/manifests/{tag}",
                headers={"Accept":"application/vnd.docker.distribution.manifest.v2+json"}
              ) or {}
              cfg = (manifest.get("config") or {}).get("digest")
              if not cfg:
                continue

              # get config blob to read "created"
              cfg_json = curl_json(f"{base}/v2/{repo}/blobs/{cfg}") or {}
              created = cfg_json.get("created")
              if not created:
                continue

              try:
                # created like: 2025-12-17T12:34:56.123Z
                dt = datetime.fromisoformat(created.replace("Z","+00:00")).astimezone(timezone.utc)
                created_ts = int(dt.timestamp())
              except Exception:
                continue

              age = now - created_ts
              if age < cutoff:
                continue

              # delete by digest
              try:
                curl(f"{base}/v2/{repo}/manifests/{digest}", method="DELETE")
                deleted += 1
                print(f"Deleted: {repo}:{tag} ({digest}) age={age}s", flush=True)
              except Exception as e:
                print(f"Skip delete {repo}:{tag} ({digest}) -> {e}", flush=True)

          print(f"Total deleted manifests: {deleted}", flush=True)

          # Write a small marker file for bash to read
          with open("/tmp/registry_deleted_count.txt","w") as f:
            f.write(str(deleted))
          PY

          DELETED_COUNT="$(cat /tmp/registry_deleted_count.txt || echo 0)"
          echo ">>> Registry deleted manifests: ${DELETED_COUNT}"

          # Optional: garbage-collect to actually free disk space (short downtime)
          if [ "${DELETED_COUNT}" -gt 0 ]; then
            echo ">>> Running registry garbage-collect (brief registry downtime)..."
            docker compose -f docker-compose.yaml stop registry || true
            docker compose -f docker-compose.yaml run --rm registry \
              bin/registry garbage-collect /etc/docker/registry/config.yml || true
            docker compose -f docker-compose.yaml start registry || true
          else
            echo ">>> Skipping garbage-collect (nothing deleted)."
          fi

          echo ">>> Deployment finished successfully."
          EOF
